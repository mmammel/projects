<!doctype html>
<html>
  <head>
    <title>WebGL Demo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="../webgl.css" type="text/css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src="../sylvester.js" type="text/javascript"></script>
    <script src="../glUtils.js" type="text/javascript"></script>
    <script src="shapeClasses.js" type="text/javascript"></script>
    <script src="rhombicTriaconta.js" type="text/javascript"></script>

    <!-- Fragment shader program -->

    <script id="shader-fs" type="x-shader/x-fragment">
      varying lowp vec4 vColor;

      void main(void) {
        gl_FragColor = vColor;
      }
    </script>

    <!-- Vertex shader program -->

    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying lowp vec4 vColor;

      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    </script>

    <script type="text/javascript">

      var faceColors = [];
      var colorChange = false;
      var drawInterval = null;
      var zoomLevel = -10;
      var ra = 0;  // right ascension in degrees.
      var dec = 0;  // declination in degrees.
      var spinRate = 0.0;  // spin rate in degrees per 15ms
      var angleIncrement = 1; //increment in degrees.


      /**
        This stuff is for the little 
        rotation axis display.
      */
      var alpha = -30; // rotation about the X-axis for the little display
      var beta = 45;  // rotation about the Y (vertical) axis for the little display

      var Grid = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1]
      ];

      var Labels = [
        [0.8,0,0.2], //+X
        [0.2,0.8,0], //+Y
        [0,0,1.2]  //+Z
      ];

      function getRotationMatrix( alpha, beta ) {
        var alphaR = alpha * Math.PI/180;
        var betaR = beta * Math.PI/180;
        var alphaRot = $M([
                         [1, 0, 0],
                         [0, Math.cos(alphaR), 1.0*Math.sin(alphaR)],
                         [0, -1.0*Math.sin(alphaR), Math.cos(alphaR)]
                       ]).snapTo(0);
        var betaRot = $M([
                         [Math.cos(betaR), 0, -1.0*Math.sin(betaR)],
                         [0, 1, 0],
                         [1.0*Math.sin(betaR), 0, Math.cos(betaR)]
                       ]).snapTo(0);

        return alphaRot.multiply( betaRot ).snapTo(0);
      }

      var P = getRotationMatrix( alpha, beta );
      
      function translate( coord ) {
        var vec = $V(coord);
        return P.multiply( vec ).elements;
      }

      function translateAll( coords ) {
        var retVal = [];
        for( var i = 0; i < coords.length; i++ ) {
          retVal.push( translate( coords[i] ) );
        }

        return retVal;
      }

      function scaleCoords( coords, factor ) {
        var retVal = [];
        for( var i = 0; i < coords.length; i++ ) {
          retVal.push( scaleCoord( coords[i], factor ) );
        }
        return retVal;
      }

      function scaleCoord( coord, factor ) {
        var mapped = coord.map( function( num ) { return num*factor + factor; } );
        //mapped[0] = 2*factor - mapped[0]; // have to flip it.
        mapped[1] = 2*factor - mapped[1]; // have to flip it.
        return mapped;
      }

      var filterFloat = function (value) {
        if(/^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
          return Number(value);
        } else {
          return NaN;
        }
      }

      function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          (1.0*parseInt(result[1], 16))/255.0,
          (1.0*parseInt(result[2], 16))/255.0,
          (1.0*parseInt(result[3], 16))/255.0,
          1.0
        ] : null;
      }

      function setFaceColors( e ) {
        faceColors = [];
        for( var i = 0; i < 15; i++ ) {
          faceColors.push( hexToRgb( $('#c'+i).val() ) );
        }
        colorChange = true;
        return true;
      }

      function setZoom(e) {
        var level = $('#zoomLevel').val();
        zoomLevel = -1.0 * parseInt(level);
      }

      function doKeyPress( e ) {
        var event = window.event ? window.event : e;
        var retVal = true;
        if( event.keyCode >= 37 && event.keyCode <= 40 ) {
          if( event.keyCode == 37 ) {
            ra -= angleIncrement;
            if( ra < 0 ) ra = 360 + ra;
          } else if( event.keyCode == 39 ) {
            ra += angleIncrement;
            if( ra >= 360 ) ra = ra - 360;
          } else if( event.keyCode == 38 ) {
            if( event.shiftKey ) {
              spinRate += .01;
            } else {
              dec -= angleIncrement;
              if( dec < 0 ) dec = 360 + dec;
            }
          } else if( event.keyCode == 40 ) {
            if( event.shiftKey ) {
              spinRate -= .01;
              if( spinRate < 0 ) spinRate = 0;
            } else {
              dec += angleIncrement;
              if( dec >= 360 ) dec = dec - 360;
            }
          }

          spinRate = filterFloat(spinRate.toFixed(2));

          populateRotVectorDisplay();

          retVal = false;
        }

        return retVal;
      }

      function getIndicatorCoords() {
        var retVal = [];
        var offsets = [ [0,10], [10,0], [0, -10], [-10,0]];
        var raOffset = 0, decOffset = 0;
        for( var i = 0; i < offsets.length; i++ ) {
          raOffset = ra + offsets[i][0];
          decOffset = dec + offsets[i][1];
          if( raOffset < 0 ) raOffset += 360;
          if( raOffset > 359 ) raOffset -= 360;
          if( decOffset < 0 ) decOffset += 360;
          if( decOffset > 359 ) decOffset -= 360;
          retVal.push( getRotationAxis( raOffset, decOffset ).elements );
        }
        return retVal;
      }

      function populateRotVectorDisplay() {
        var rotVec = getRotationAxis(ra, dec);

        var indicator = getIndicatorCoords(); // get a little square around the end of the vector.

        var antiRotVec = $V([0,0,0]).subtract( rotVec );
        var rotVecTranslate = scaleCoord( translate( rotVec.elements ), 100 );
        var indicatorTranslate = scaleCoords( translateAll( indicator ), 100 );

        var indicatorPoints = "";
        for( var ip = 0; ip < indicatorTranslate.length; ip++ ) {
          if( ip > 0 ) indicatorPoints += " ";
          indicatorPoints += ( indicatorTranslate[ip][0] + "," + indicatorTranslate[ip][1] );
        }

        //var rotVecXYShadow = scaleCoord( translate( [ rotVec.elements[0], rotVec.elements[1], 0 ] ), 100 );
        //var rotVecYZShadow = scaleCoord( translate( [ 0, rotVec.elements[1], rotVec.elements[2] ] ), 100 );
        var antiRotVecTranslate = scaleCoord( translate( antiRotVec.elements ), 100 );
        //var antiRotVecXYShadow = scaleCoord( translate( [ antiRotVec.elements[0], antiRotVec.elements[1], 0 ] ), 100 );
        //var antiRotVecYZShadow = scaleCoord( translate( [ 0, antiRotVec.elements[1], antiRotVec.elements[2] ] ), 100 );
        var origin = scaleCoord( translate( [ 0,0,0 ] ), 100 );
        var content = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="200" height="200">';

        var t = translateAll( Grid );
        var st = scaleCoords( t, 100 );
        var l = scaleCoords( translateAll( Labels ), 100 );
        for( var i = 0; i < t.length; i+=2 ) {
          content += '<line x1="'+st[i][0]+'" y1="'+st[i][1]+'" x2="'+st[i+1][0]+'" y2="'+st[i+1][1]+'" style="stroke:rgb(0,0,0);stroke-width:1" />';
        }
        content += '<line x1="'+rotVecTranslate[0]+'" y1="'+rotVecTranslate[1]+'" x2="'+antiRotVecTranslate[0]+'" y2="'+antiRotVecTranslate[1]+'" style="stroke:rgb(255,0,0);stroke-width:2" />';
        //content += '<line x1="'+rotVecTranslate[0]+'" y1="'+rotVecTranslate[1]+'" x2="'+rotVecXYShadow[0]+'" y2="'+rotVecXYShadow[1]+'" style="stroke:rgb(255,0,0);stroke-width:1" />';
        //content += '<line x1="'+antiRotVecTranslate[0]+'" y1="'+antiRotVecTranslate[1]+'" x2="'+antiRotVecXYShadow[0]+'" y2="'+antiRotVecXYShadow[1]+'" style="stroke:rgb(255,0,0);stroke-width:1" />';
        //content += '<line x1="'+rotVecTranslate[0]+'" y1="'+rotVecTranslate[1]+'" x2="'+rotVecYZShadow[0]+'" y2="'+rotVecYZShadow[1]+'" style="stroke:rgb(255,0,0);stroke-width:1" />';
        //content += '<line x1="'+antiRotVecTranslate[0]+'" y1="'+antiRotVecTranslate[1]+'" x2="'+antiRotVecYZShadow[0]+'" y2="'+antiRotVecYZShadow[1]+'" style="stroke:rgb(255,0,0);stroke-width:1" />';
        //content += '<line x1="'+rotVecYZShadow[0]+'" y1="'+rotVecYZShadow[1]+'" x2="'+antiRotVecYZShadow[0]+'" y2="'+antiRotVecYZShadow[1]+'" style="stroke:rgb(255,0,0);stroke-width:1" />';
        //content += '<line x1="'+rotVecXYShadow[0]+'" y1="'+rotVecXYShadow[1]+'" x2="'+antiRotVecXYShadow[0]+'" y2="'+antiRotVecXYShadow[1]+'" style="stroke:rgb(255,0,0);stroke-width:1" />';
        content += '<text x="'+l[0][0]+'" y="'+l[0][1]+'">+x</text>';
        content += '<text x="'+l[1][0]+'" y="'+l[1][1]+'">+y</text>';
        content += '<text x="'+l[2][0]+'" y="'+l[2][1]+'">+z</text>';
        content += '<polygon points="'+indicatorPoints+'" style="fill:rgb(255,0,0);fill-opacity:.4;"/>';
        content += '</svg>';
        
        $('#rotVector').html( content );
      }

      $(document).keydown( doKeyPress );

      $(document).ready(function() {
        populateRotVectorDisplay();
        setFaceColors();
        $("input[type='color']").on("change", setFaceColors);
        Sylvester.precision = 0.0001
        start();
      });

      function changePoly( verts ) {

        clearInterval(drawInterval);
        poly = new Polyhedron( verts );

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
        var vertices = poly.getFaceOrderedVertices();
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        setColors();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);

        var cubeVertexIndices = poly.triangleVertices;

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);

        changeColors = true;

        drawInterval = setInterval( drawScene, 15 );
      }
    </script>
  </head>

  <body>
    <table>
      <tr>
        <td>
    <canvas id="glcanvas" width="640" height="480">
      Your browser doesn't appear to support the <code>&lt;canvas&gt;</code> element.
    </canvas>
        </td>
        <td>
          <div><input type="color" id="c0" value="#ff0000"></input></div>
          <div><input type="color" id="c1" value="#ff9900"></input></div>
          <div><input type="color" id="c2" value="#ffff00"></input></div>
          <div><input type="color" id="c3" value="#0000ff"></input></div>
          <div><input type="color" id="c4" value="#9900cc"></input></div>
          <div><input type="color" id="c5" value="#1dc717"></input></div>
          <div><input type="color" id="c6" value="#2de7c7"></input></div>
          <div><input type="color" id="c7" value="#3df7d7"></input></div>
          <div><input type="color" id="c8" value="#4d17e7"></input></div>
          <div><input type="color" id="c9" value="#5d37f7"></input></div>
          <div><input type="color" id="c10" value="#6d5717"></input></div>
          <div><input type="color" id="c11" value="#7d7737"></input></div>
          <div><input type="color" id="c12" value="#8d9757"></input></div>
          <div><input type="color" id="c13" value="#fd1717"></input></div>
          <div><input type="color" id="c14" value="#fdf7f7"></input></div>
          <div><label for="zoomLevel">Zoom: </label><input type="range" id="zoomLevel" name="points" value="30" oninput="setZoom();" min="0" max="100"></div>
        </td>
      </tr>
      <tr>
        <td>
          <ul>
            <li><a href="#" onclick="changePoly(rt_polyVerts);">Rhombic Triacontahedron</a></li>
            <li><a href="#" onclick="changePoly(cube_polyVerts);">Cube</a></li>
            <li><a href="#" onclick="changePoly(dodecahedron_polyVerts);">Dodecahedron</a></li>
            <li><a href="#" onclick="changePoly(pyramid_polyVerts);">Pyramid</a></li>
            <li><a href="#" onclick="changePoly(rhombicDodecahedron_polyVerts);">Rhombic Dodecahedron</a></li>
            <li><a href="#" onclick="changePoly(icosahedron_polyVerts);">Icosahedron</a></li>
            <li><a href="#" onclick="changePoly(giant_polyVerts);">Enneacontahedron</a></li>
          </ul>
        </td>
        <td>
          <div id="rotVector"></div>
        </td>
      </tr>
    </table>
  </body>
</html>
