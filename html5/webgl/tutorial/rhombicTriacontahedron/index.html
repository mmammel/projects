<!doctype html>
<html>
  <head>
    <title>WebGL Demo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="../webgl.css" type="text/css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src="../sylvester.js" type="text/javascript"></script>
    <script src="../glUtils.js" type="text/javascript"></script>
    <script src="shapeClasses.js" type="text/javascript"></script>
    <script src="rhombicTriaconta.js" type="text/javascript"></script>

    <!-- Fragment shader program -->

    <script id="shader-fs" type="x-shader/x-fragment">
      varying lowp vec4 vColor;

      void main(void) {
        gl_FragColor = vColor;
      }
    </script>

    <!-- Vertex shader program -->

    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying lowp vec4 vColor;

      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    </script>

    <script type="text/javascript">

      var faceColors = [];
      var colorChange = false;
      var drawInterval = null;
      var zoomLevel = -10;
      var rotAxis = $V([1,0,0]);
      var spinRate = 0.0;  // spin rate in degrees per 15ms
      var angleIncrement = 1; //increment in degrees.


      /**
        This stuff is for the little 
        rotation axis display.
      */
      var alpha = -30; // rotation about the X-axis for the little display
      var beta = 45;  // rotation about the Y (vertical) axis for the little display

      var Grid = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1]
      ];

      var Labels = [
        [0.8,0,0.2], //+X
        [0.2,0.8,0], //+Y
        [0,0,1.2]  //+Z
      ];

      function getRotationMatrix( alpha, beta ) {
        var alphaR = alpha * Math.PI/180;
        var betaR = beta * Math.PI/180;
        var alphaRot = $M([
                         [1, 0, 0],
                         [0, Math.cos(alphaR), 1.0*Math.sin(alphaR)],
                         [0, -1.0*Math.sin(alphaR), Math.cos(alphaR)]
                       ]).snapTo(0);
        var betaRot = $M([
                         [Math.cos(betaR), 0, -1.0*Math.sin(betaR)],
                         [0, 1, 0],
                         [1.0*Math.sin(betaR), 0, Math.cos(betaR)]
                       ]).snapTo(0);

        return alphaRot.multiply( betaRot ).snapTo(0);
      }

      var P = getRotationMatrix( alpha, beta );
      
      function translate( coord ) {
        var vec = $V(coord);
        return P.multiply( vec ).elements;
      }

      function translateAll( coords ) {
        var retVal = [];
        for( var i = 0; i < coords.length; i++ ) {
          retVal.push( translate( coords[i] ) );
        }

        return retVal;
      }

      function scaleCoords( coords, factor ) {
        var retVal = [];
        for( var i = 0; i < coords.length; i++ ) {
          retVal.push( scaleCoord( coords[i], factor ) );
        }
        return retVal;
      }

      function scaleCoord( coord, factor ) {
        var mapped = coord.map( function( num ) { return num*factor + factor; } );
        //mapped[0] = 2*factor - mapped[0]; // have to flip it.
        mapped[1] = 2*factor - mapped[1]; // have to flip it.
        return mapped;
      }

      var filterFloat = function (value) {
        if(/^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
          return Number(value);
        } else {
          return NaN;
        }
      }

      function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          (1.0*parseInt(result[1], 16))/255.0,
          (1.0*parseInt(result[2], 16))/255.0,
          (1.0*parseInt(result[3], 16))/255.0,
          1.0
        ] : null;
      }

      function setFaceColors( e ) {
        faceColors = [];
        for( var i = 0; i < 15; i++ ) {
          faceColors.push( hexToRgb( $('#c'+i).val() ) );
        }
        colorChange = true;
        return true;
      }

      function setZoom(e) {
        var level = $('#zoomLevel').val();
        zoomLevel = -1.0 * parseInt(level);
      }

      var touchContext = {};

      function processTouch() {
        var duration = touchContext.endTime - touchContext.startTime;
        spinRate = 1000.0 / duration;
        getRotationAxisFromPoints( touchContext.startX, touchContext.startY, touchContext.endX, touchContext.endY );
        populateRotVectorDisplay();
      }
      
      var guideSphere = {};
      function setupGuideSphere() {
        guideSphere.centerX = ($('#glcanvas').width() / 2) + $('#glcanvas').offset().left;
        guideSphere.centerY = ($('#glcanvas').height() / 2) + $('#glcanvas').offset().top;
        guideSphere.radius = guideSphere.centerY;
      }
      
      /*
       * pageX: pixels from left
       * pageY: pixels from top
       * We have raw page coordinates, find the x,y,z relative to the center of the 
       * guide sphere.
       */
      function getSphereCoordFromPageCoord( pageX, pageY ) {
        var realX = pageX - guideSphere.centerX;
        var realY = guideSphere.centerY - pageY;
        // get distance from the center, when looking down the z-axis
        var littleR = Math.sqrt( Math.pow( realX, 2) + Math.pow( realY, 2 ) );
        if( littleR > guideSphere.radius ) littleR = guideSphere.radius;
        var realZ = Math.sqrt( Math.pow( guideSphere.radius, 2) - Math.pow( littleR, 2) );
        return $V([realX, realY, realZ]).toUnitVector();
      }

      function getRotationAxisFromPoints( startX, startY, endX, endY ) {
        var vecA = getSphereCoordFromPageCoord( startX, startY );
        var vecB = getSphereCoordFromPageCoord( endX, endY );
        var cross = vecA.cross( vecB ).toUnitVector();
        rotAxis = cross;
      }

      $(document).ready(function() {
        setupGuideSphere();
        $('#glcanvas').on( "touchstart", function(event) {
         event.preventDefault();
         touchContext.startX = event.originalEvent.touches[0].pageX;
         touchContext.startY = event.originalEvent.touches[0].pageY;
         var d = new Date();
         touchContext.startTime = d.getTime();
        }).on("touchend", function(event) {
         event.preventDefault();
         touchContext.endX = event.originalEvent.changedTouches[0].pageX;
         touchContext.endY = event.originalEvent.changedTouches[0].pageY;
         var d = new Date();
         touchContext.endTime = d.getTime();
         processTouch();
        }).on( "mousedown", function(event) {
         touchContext.startX = event.pageX;
         touchContext.startY = event.pageY;
         var d = new Date();
         touchContext.startTime = d.getTime();
        }).on("mouseup", function(event) {
         touchContext.endX = event.pageX;
         touchContext.endY = event.pageY;
         var d = new Date();
         touchContext.endTime = d.getTime();
         processTouch();
        });
        setFaceColors();
        $("input[type='color']").on("change", setFaceColors);
        Sylvester.precision = 0.0001
        start();
      });

      function changePoly( verts ) {

        clearInterval(drawInterval);
        poly = new Polyhedron( verts );

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
        var vertices = poly.getFaceOrderedVertices();
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        setColors();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);

        var cubeVertexIndices = poly.triangleVertices;

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);

        changeColors = true;

        drawInterval = setInterval( drawScene, 15 );
      }

      function doCustomVertices() {
        eval( $('#customVertices').val() );
        changePoly( vertices );
      }
    </script>
  </head>

  <body>
    <table>
      <tr>
        <td>
    <canvas id="glcanvas" width="640" height="480">
      Your browser doesn't appear to support the <code>&lt;canvas&gt;</code> element.
    </canvas>
        </td>
        <td>
          <div><input type="color" id="c0" value="#ff0000"></input></div>
          <div><input type="color" id="c1" value="#ff9900"></input></div>
          <div><input type="color" id="c2" value="#ffff00"></input></div>
          <div><input type="color" id="c3" value="#0000ff"></input></div>
          <div><input type="color" id="c4" value="#9900cc"></input></div>
          <div><input type="color" id="c5" value="#1dc717"></input></div>
          <div><input type="color" id="c6" value="#2de7c7"></input></div>
          <div><input type="color" id="c7" value="#3df7d7"></input></div>
          <div><input type="color" id="c8" value="#4d17e7"></input></div>
          <div><input type="color" id="c9" value="#5d37f7"></input></div>
          <div><input type="color" id="c10" value="#6d5717"></input></div>
          <div><input type="color" id="c11" value="#7d7737"></input></div>
          <div><input type="color" id="c12" value="#8d9757"></input></div>
          <div><input type="color" id="c13" value="#fd1717"></input></div>
          <div><input type="color" id="c14" value="#fdf7f7"></input></div>
          <div><label for="zoomLevel">Zoom: </label><input type="range" id="zoomLevel" name="points" value="30" oninput="setZoom();" min="0" max="100"></div>
        </td>
      </tr>
    </table>
    <table>
      <tr>
        <td width="50%">
          <ul>
            <li><a href="#" onclick="changePoly(rt_polyVerts);">Rhombic Triacontahedron</a></li>
            <li><a href="#" onclick="changePoly(cube_polyVerts);">Cube</a></li>
            <li><a href="#" onclick="changePoly(dodecahedron_polyVerts);">Dodecahedron</a></li>
            <li><a href="#" onclick="changePoly(pyramid_polyVerts);">Pyramid</a></li>
            <li><a href="#" onclick="changePoly(rhombicDodecahedron_polyVerts);">Rhombic Dodecahedron</a></li>
            <li><a href="#" onclick="changePoly(icosahedron_polyVerts);">Icosahedron</a></li>
            <li><a href="#" onclick="changePoly(giant_polyVerts);">Enneacontahedron</a></li>
            <li><a href="#" onclick="changePoly(fccPrimitive_polyVerts);">FCC Primitive</a></li>
            <li><a href="#" onclick="changePoly(officialPrimitive_polyVerts);">Official FCC Primitive</a></li>
            <li><a href="#" onclick="changePoly(squatSoma_polyVerts);">Squat Cube</a></li>
            <li><a href="#" onclick="changePoly(tetartoid_polyVerts);">Tetartoid</a></li>
          </ul>
        </td>
        <!--<td>
          <label for="customVertices">Custom Vertices</label>
          <textarea id="customVertices" rows="10" cols="30" placeholder="Write some javascript that assigns an array of floats to a variable called "customVerts", then press \"Submit\""></textarea><br><button onclick="doCustomVertices();" id="customVerticesSubmit">Submit</button>
        </td>-->
        <td>
          <h5>Instructions</h5>
          <ul>
            <li>Rotate the shape using a mouse stroke or finger swipe across the shape.</li>
          </ul>
        </td>
        <td>
          <div id="rotVector"></div>
        </td>
      </tr>
    </table>
  </body>
</html>
