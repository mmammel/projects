<!doctype html>
<html>
  <head>
    <title>WebGL Demo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="../webgl.css" type="text/css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src="../sylvester.js" type="text/javascript"></script>
    <script src="../glUtils.js" type="text/javascript"></script>
    <script src="shapeClasses.js" type="text/javascript"></script>
    <script src="apiConnect.js" type="text/javascript"></script>
    <script src="rhombicTriaconta.js" type="text/javascript"></script>

    <!-- Fragment shader program -->

    <script id="shader-fs" type="x-shader/x-fragment">
      varying lowp vec4 vColor;

      void main(void) {
        gl_FragColor = vColor;
      }
    </script>

    <!-- Vertex shader program -->

    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying lowp vec4 vColor;

      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    </script>

    <script type="text/javascript">

      var faceColors = [];
      var colorChange = false;
      var drawInterval = null;
      var zoomLevel = -10;

      // For smooth rotation changes.
      var targetRotAxis = $V([1,0,0]);
      var currTargetRotAxis = null;
      var rotAxis = $V([1,0,0]);
      var currSteps = [0,0,0]; // steps to get to target vector in 60 cycles.
      var rotationTransitionInterval = null;

      var spinRate = 0.0;  // spin rate in degrees per 15ms

      /**
        This stuff is for the little 
        rotation axis display.
      */
      var alpha = -30; // rotation about the X-axis for the little display
      var beta = 45;  // rotation about the Y (vertical) axis for the little display

      var Grid = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1]
      ];

      var Labels = [
        [0.8,0,0.2], //+X
        [0.2,0.8,0], //+Y
        [0,0,1.2]  //+Z
      ];

      function getRotationMatrix( alpha, beta ) {
        var alphaR = alpha * Math.PI/180;
        var betaR = beta * Math.PI/180;
        var alphaRot = $M([
                         [1, 0, 0],
                         [0, Math.cos(alphaR), 1.0*Math.sin(alphaR)],
                         [0, -1.0*Math.sin(alphaR), Math.cos(alphaR)]
                       ]).snapTo(0);
        var betaRot = $M([
                         [Math.cos(betaR), 0, -1.0*Math.sin(betaR)],
                         [0, 1, 0],
                         [1.0*Math.sin(betaR), 0, Math.cos(betaR)]
                       ]).snapTo(0);

        return alphaRot.multiply( betaRot ).snapTo(0);
      }

      var P = getRotationMatrix( alpha, beta );
      
      function translate( coord ) {
        var vec = $V(coord);
        return P.multiply( vec ).elements;
      }

      function translateAll( coords ) {
        var retVal = [];
        for( var i = 0; i < coords.length; i++ ) {
          retVal.push( translate( coords[i] ) );
        }

        return retVal;
      }

      function scaleCoords( coords, factor ) {
        var retVal = [];
        for( var i = 0; i < coords.length; i++ ) {
          retVal.push( scaleCoord( coords[i], factor ) );
        }
        return retVal;
      }

      function scaleCoord( coord, factor ) {
        var mapped = coord.map( function( num ) { return num*factor + factor; } );
        //mapped[0] = 2*factor - mapped[0]; // have to flip it.
        mapped[1] = 2*factor - mapped[1]; // have to flip it.
        return mapped;
      }

      var filterFloat = function (value) {
        if(/^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
          return Number(value);
        } else {
          return NaN;
        }
      }

      function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          (1.0*parseInt(result[1], 16))/255.0,
          (1.0*parseInt(result[2], 16))/255.0,
          (1.0*parseInt(result[3], 16))/255.0,
          1.0
        ] : null;
      }

      function setFaceColors( e ) {
        faceColors = [];
        for( var i = 0; i < 15; i++ ) {
          faceColors.push( hexToRgb( $('#c'+i).val() ) );
        }
        colorChange = true;
        return true;
      }

      function setZoom(e) {
        var level = $('#zoomLevel').val();
        zoomLevel = -1.0 * parseInt(level);
      }

      var touchContext = {};

      function processTouch() {
        var duration = touchContext.endTime - touchContext.startTime;
        var distance = Math.sqrt( Math.pow((touchContext.endX - touchContext.startX),2) + Math.pow((touchContext.endY - touchContext.startY),2));
        if( Math.abs( distance ) < .01 ) {
          spinRate = 0;
        } else {
          spinRate = 2.5 * (distance / duration);
          getRotationAxisFromPoints( touchContext.startX, touchContext.startY, touchContext.endX, touchContext.endY );
        }
      }
      
      var guideSphere = {};
      function setupGuideSphere() {
        guideSphere.centerX = ($('#glcanvas').width() / 2) + $('#glcanvas').offset().left;
        guideSphere.centerY = ($('#glcanvas').height() / 2) + $('#glcanvas').offset().top;
        guideSphere.radius = guideSphere.centerY;
      }
      
      /*
       * pageX: pixels from left
       * pageY: pixels from top
       * We have raw page coordinates, find the x,y,z relative to the center of the 
       * guide sphere.
       */
      function getSphereCoordFromPageCoord( pageX, pageY ) {
        var realX = pageX - guideSphere.centerX;
        var realY = guideSphere.centerY - pageY;
        // get distance from the center, when looking down the z-axis
        var littleR = Math.sqrt( Math.pow( realX, 2) + Math.pow( realY, 2 ) );
        if( littleR > guideSphere.radius ) littleR = guideSphere.radius;
        var realZ = Math.sqrt( Math.pow( guideSphere.radius, 2) - Math.pow( littleR, 2) );
        return $V([realX, realY, realZ]).toUnitVector();
      }

      function getRotationAxisFromPoints( startX, startY, endX, endY ) {
        var vecA = getSphereCoordFromPageCoord( startX, startY );
        var vecB = getSphereCoordFromPageCoord( endX, endY );
        var cross = vecA.cross( vecB ).toUnitVector();
        targetRotAxis = cross;
      }

      $(document).ready(function() {
        setupGuideSphere();
        $('#glcanvas').on( "touchstart", function(event) {
         event.preventDefault();
         touchContext.startX = event.originalEvent.touches[0].pageX;
         touchContext.startY = event.originalEvent.touches[0].pageY;
         var d = new Date();
         touchContext.startTime = d.getTime();
        }).on("touchend", function(event) {
         event.preventDefault();
         touchContext.endX = event.originalEvent.changedTouches[0].pageX;
         touchContext.endY = event.originalEvent.changedTouches[0].pageY;
         var d = new Date();
         touchContext.endTime = d.getTime();
         processTouch();
        }).on( "mousedown", function(event) {
         touchContext.startX = event.pageX;
         touchContext.startY = event.pageY;
         var d = new Date();
         touchContext.startTime = d.getTime();
        }).on("mouseup", function(event) {
         touchContext.endX = event.pageX;
         touchContext.endY = event.pageY;
         var d = new Date();
         touchContext.endTime = d.getTime();
         processTouch();
        });

        rotationTransitionInterval = setInterval( function() {
          if( !rotAxis.eql( targetRotAxis ) ) {
            if( currTargetRotAxis == null ) {
              // start of a new transition
              currTargetRotAxis = targetRotAxis.dup();
              currSteps[0] = (currTargetRotAxis.elements[0] - rotAxis.elements[0])/40;
              currSteps[1] = (currTargetRotAxis.elements[1] - rotAxis.elements[1])/40;
              currSteps[2] = (currTargetRotAxis.elements[2] - rotAxis.elements[2])/40;
            } else if( !currTargetRotAxis.eql( targetRotAxis ) ) {
              // We changed targets mid-flight, that's ok - just reset
              currTargetRotAxis = null;
              return;
            }
            
            rotAxis.elements[0] += currSteps[0];
            rotAxis.elements[1] += currSteps[1];
            rotAxis.elements[2] += currSteps[2];

          } else {
            currTargetRotAxis = null;
          }
        }, 15 ); 
        setFaceColors();
        $("input[type='color']").on("change", setFaceColors);
        Sylvester.precision = 0.0001
        start();
        getPolyhedra();
      });

      function changePoly( verts ) {

        clearInterval(drawInterval);
        poly = new Polyhedron( verts );

        cubeVerticesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
        var vertices = poly.getFaceOrderedVertices();
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        setColors();

        cubeVerticesIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);

        var cubeVertexIndices = poly.triangleVertices;

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);

        changeColors = true;

        drawInterval = setInterval( drawScene, 15 );
      }

      function loadVertices() {
        eval( $('#polyVerts').val() );
        changePoly( vertices );
      }
    </script>
  </head>

  <body>
    <table>
      <tr>
        <td>
    <canvas id="glcanvas" width="640" height="640">
      Your browser doesn't appear to support the <code>&lt;canvas&gt;</code> element.
    </canvas>
        </td>
        <td>
          <div><input type="color" id="c0" value="#ff0000"></input></div>
          <div><input type="color" id="c1" value="#ff9900"></input></div>
          <div><input type="color" id="c2" value="#ffff00"></input></div>
          <div><input type="color" id="c3" value="#0000ff"></input></div>
          <div><input type="color" id="c4" value="#9900cc"></input></div>
          <div><input type="color" id="c5" value="#1dc717"></input></div>
          <div><input type="color" id="c6" value="#2de7c7"></input></div>
          <div><input type="color" id="c7" value="#3df7d7"></input></div>
          <div><input type="color" id="c8" value="#4d17e7"></input></div>
          <div><input type="color" id="c9" value="#5d37f7"></input></div>
          <div><input type="color" id="c10" value="#6d5717"></input></div>
          <div><input type="color" id="c11" value="#7d7737"></input></div>
          <div><input type="color" id="c12" value="#8d9757"></input></div>
          <div><input type="color" id="c13" value="#fd1717"></input></div>
          <div><input type="color" id="c14" value="#fdf7f7"></input></div>
          <div style="width: 8px; padding-left: 24px;">-</div>
          <div style="padding-left: 20px"><input type="range" id="zoomLevel" name="points" value="30" oninput="setZoom();" style="width:8px; height:150px; writing-mode: bt-lr; -webkit-appearance: slider-vertical;" min="0" max="100"></div>
          <div style="width: 8px; padding-left: 21px">+</div>
        </td>
        <td id="polyForm">
          <table>
            <tr>
              <td>
              <select id="polySelect" onchange="loadPolyhedron();">
                <option value="-1" selected>Select A Shape</option>
              </select>
            </td></tr>
            <tr>
              <td>
              <input type="hidden" id="polyId" name="polyId" value="">
              <input placeholder="Enter a Name" type="text" id="polyName" name="polyName" value="" style="width:196px;" onchange="updateSaveButton();">
            </td></tr>
            <tr><td>
              <textarea id="polyDesc" rows="4" cols="30" placeholder="Enter a description"></textarea>
            </td></tr>
            <tr><td>
              <textarea placeholder="Define the vertex array" title="Using javascript, define float array and assign to 'vertices'" id="polyVerts" rows="25" cols="30" onkeyup="updateSaveButton();"></textarea>
            </td><td><p>Using javascript, write some code that assigns a one-dimensional array of floats (every three elements is vertex) to a variable named "vertices".  For example: <code style="font-size:small"><pre>
  vertices  = [
        1,1,1,
        1,-1,1,
        -1,1,1,
        -1,-1,1,
        1,1,-1,
        1,-1,-1,
        -1,1,-1,
        -1,-1,-1
    ];

</pre></code>defines a cube.</p></td></tr>
            <tr><td>
              <button id="polySave" onclick="savePolyhedron();">Save</button>
              <button id="polyMakeNew" onclick="clearForm();">New</button>
              <button id="polyClear" onclick="clearForm();">Clear</button>
            </td></tr>
          </table>
        </td>
      </tr>
    </table>
  </body>
</html>
